// Generated by CoffeeScript 1.3.3
(function() {
  var BLOCKS, Block, CANVAS_HEIGHT, CANVAS_WIDTH, COLORS, COMPOSITE, CONTEXT, COUNTS, CURRENT_BLOCK_HEADER, FLOORS, FPS, GRID, HEIGHT, INTERVAL, IS_END, KEY_DOWN, KEY_LEFT, KEY_RIGHT, KEY_SPACE, PREFIX, START, START_X, START_Y, Stage, VELOCITY_X, VELOCITY_Y, VELOCITY_Y_RAW, VELOCITY_Y_STEP, WIDTH,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  FPS = 30;

  INTERVAL = 1000 / FPS;

  WIDTH = 20;

  HEIGHT = WIDTH;

  CANVAS_WIDTH = 320;

  CANVAS_HEIGHT = 400;

  FLOORS = CANVAS_HEIGHT / HEIGHT - 1;

  COUNTS = CANVAS_WIDTH / WIDTH;

  START_X = CANVAS_WIDTH / 2 - WIDTH;

  START_Y = 0;

  VELOCITY_X = 0;

  VELOCITY_Y_STEP = 3;

  VELOCITY_Y_RAW = VELOCITY_Y = 4;

  GRID = [];

  BLOCKS = [];

  COMPOSITE = {
    COMPOSITE_1: [[[-1, -1], [0, -1], [-1, 0]]],
    COMPOSITE_2: [[[0, -1], [0, -2], [0, -3]], [[1, 0], [2, 0], [3, 0]]],
    COMPOSITE_3: [[[0, -1], [1, 0], [-1, 0]], [[0, -1], [0, -2], [1, -1]], [[-1, -1], [0, -1], [1, -1]], [[0, -2], [0, -1], [-1, -1]]],
    COMPOSITE_4: [[[0, -1], [0, -2], [1, 0]], [[0, -1], [1, -1], [2, -1]], [[0, -1], [0, -2], [-1, -2]], [[0, -1], [-1, 0], [-2, 0]]],
    COMPOSITE_5: [[[0, -1], [1, -1], [-1, 0]], [[0, -1], [-1, -1], [-1, -2]]],
    COMPOSITE_6: [[[0, -1], [1, -1], [1, -2]], [[1, 0], [0, -1], [-1, -1]]]
  };

  COLORS = ['#2F4F4F', '#8A2BE2', '#008B8B', '#FF9900', '#1E90FF'];

  CONTEXT = null;

  CURRENT_BLOCK_HEADER = null;

  START = null;

  KEY_LEFT = [37, 72];

  KEY_RIGHT = [39, 76];

  KEY_DOWN = [40, 74];

  KEY_SPACE = 32;

  PREFIX = 'COMPOSITE_';

  IS_END = false;

  Block = (function() {

    function Block(x, y, width, height, color) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.color = color;
    }

    Block.prototype.draw = function(ctx) {
      ctx.beginPath();
      ctx.rect(this.x, this.y, this.width - 1, this.height - 1);
      ctx.fillStyle = this.color;
      ctx.fill();
      ctx.lineWidth = 0.5;
      ctx.strokeStyle = '#fff';
      return ctx.stroke();
    };

    Block.prototype.updateShape = function() {
      var composites, shape;
      if (!(this.feature != null)) {
        return;
      }
      composites = COMPOSITE[PREFIX + this.feature[0]];
      shape = this.feature[1] + 1;
      return this.feature[1] = shape >= composites.length ? 0 : shape;
    };

    return Block;

  })();

  Stage = (function() {

    function Stage() {
      var canvas, i, _i;
      this.bindEvent();
      canvas = document.getElementById('stage');
      canvas.width = CANVAS_WIDTH;
      canvas.height = CANVAS_HEIGHT;
      for (i = _i = 0; 0 <= FLOORS ? _i <= FLOORS : _i >= FLOORS; i = 0 <= FLOORS ? ++_i : --_i) {
        GRID.push({
          blocks: new Array(COUNTS),
          count: 0
        });
      }
      CONTEXT = canvas.getContext('2d');
      START = +new Date();
      this.render();
    }

    Stage.prototype.generateComposite = function() {
      var block, block_header, color, composite, composites, i, shape, type, _i;
      if (IS_END) {
        return;
      }
      type = Math.ceil(Math.random() * 6);
      color = COLORS[Math.floor(Math.random() * COLORS.length)];
      composites = COMPOSITE[PREFIX + type];
      if (!(composites != null)) {
        return;
      }
      shape = Math.round(Math.random() * (composites.length - 1));
      composite = composites[shape];
      block_header = new Block(START_X, START_Y, WIDTH, HEIGHT, color);
      block_header.feature = [type, shape];
      BLOCKS.push(block_header);
      for (i = _i = 0; _i <= 2; i = ++_i) {
        block = new Block(START_X + composite[i][0] * WIDTH, START_Y + composite[i][1] * HEIGHT, WIDTH, HEIGHT, color);
        BLOCKS.push(block);
      }
      return CURRENT_BLOCK_HEADER = block_header;
    };

    Stage.prototype.getGridPosition = function(x, y) {
      return {
        row: Math.floor((y + HEIGHT) / HEIGHT),
        col: Math.floor(x / WIDTH)
      };
    };

    Stage.prototype.getGridCollision = function(row, col) {
      var floor, is_collision;
      is_collision = false;
      floor = GRID[row];
      if (row > FLOORS || (floor && floor.blocks[col]) || col < 0 || col > COUNTS - 1) {
        is_collision = true;
      }
      return is_collision;
    };

    Stage.prototype.updateComposite = function(blocks, feature) {
      var composite, current_x, current_y, delta_x, delta_y, header_x, header_y, i, is_collision_x, is_collision_y, pos_x, pos_y, _i, _ref;
      if (!blocks.length || IS_END) {
        return;
      }
      header_x = blocks[0].x + VELOCITY_X;
      header_y = blocks[0].y + VELOCITY_Y;
      composite = COMPOSITE[PREFIX + feature[0]][feature[1]];
      for (i = _i = 0, _ref = blocks.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        delta_x = i === 0 ? 0 : composite[i - 1][0] * WIDTH;
        delta_y = i === 0 ? 0 : composite[i - 1][1] * HEIGHT;
        current_x = header_x + delta_x;
        current_y = header_y + delta_y;
        pos_y = this.getGridPosition(blocks[i].x, current_y);
        is_collision_y = this.getGridCollision(pos_y.row, pos_y.col);
        if (is_collision_y) {
          current_y = (pos_y.row - 1) * HEIGHT;
          blocks[0].y = current_y - delta_y;
          break;
        }
        pos_x = this.getGridPosition(current_x, blocks[i].y);
        is_collision_x = this.getGridCollision(pos_x.row, pos_x.col);
        if (is_collision_x) {
          current_x = blocks[i].x;
          blocks[0].x = current_x - delta_x;
        }
        blocks[i].x = current_x;
        blocks[i].y = current_y;
      }
      this.drawComposite(blocks, composite);
      if (is_collision_y) {
        delete blocks[0].feature;
        this.setGridStatus(blocks);
        return this.generateComposite();
      }
    };

    Stage.prototype.setBlocksFlag = function(rows) {
      var blocks, cal_row, floor, i, j, max_row, pos, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3, _ref4, _results;
      if (!rows.length) {
        return;
      }
      rows.sort(function(a, b) {
        return a < b;
      });
      max_row = rows[rows.length - 1];
      for (i = _i = 0, _ref = rows.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        blocks = GRID[rows[i]].blocks;
        for (j = _j = 0, _ref1 = blocks.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          blocks[j].flag = 1;
        }
      }
      blocks = GRID[max_row].blocks;
      for (i = _k = 0, _ref2 = blocks.length - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        cal_row = max_row;
        pos = this.getGridPosition(blocks[i].x, blocks[i].y);
        while ((floor = GRID[--cal_row]) != null) {
          if (floor.blocks[pos.col] != null) {
            floor.blocks[pos.col].step = rows.length;
          }
        }
      }
      for (i = _l = 0, _ref3 = rows.length - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
        GRID.splice(rows[i], 1);
      }
      _results = [];
      for (i = _m = 0, _ref4 = rows.length - 1; 0 <= _ref4 ? _m <= _ref4 : _m >= _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
        _results.push(GRID.unshift({
          blocks: new Array(COUNTS),
          count: 0
        }));
      }
      return _results;
    };

    Stage.prototype.setGridStatus = function(blocks) {
      var down_rows, floor, i, pos, _i, _ref;
      down_rows = [];
      for (i = _i = 0, _ref = blocks.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        pos = this.getGridPosition(blocks[i].x, blocks[i].y);
        floor = GRID[pos.row - 1];
        if (!(floor != null)) {
          IS_END = true;
          return;
        }
        floor.blocks[pos.col] = blocks[i];
        if (++floor.count === COUNTS) {
          down_rows.push(pos.row - 1);
        }
      }
      return this.setBlocksFlag(down_rows);
    };

    Stage.prototype.drawComposite = function(blocks, composite_params) {
      var i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = blocks.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (i !== 0) {
          blocks[i].x = blocks[0].x + composite_params[i - 1][0] * WIDTH;
          blocks[i].y = blocks[0].y + composite_params[i - 1][1] * HEIGHT;
        }
        _results.push(blocks[i].draw(CONTEXT));
      }
      return _results;
    };

    Stage.prototype.update = function() {
      var block, feature, flag, i, new_blocks, pos, step, _i, _j, _ref, _ref1, _results;
      CONTEXT.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      if (BLOCKS.length === 0) {
        this.generateComposite();
      }
      new_blocks = [];
      for (i = _i = 0, _ref = BLOCKS.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (!BLOCKS[i].flag) {
          new_blocks.push(BLOCKS[i]);
        }
      }
      BLOCKS = new_blocks;
      _results = [];
      for (i = _j = 0, _ref1 = BLOCKS.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        block = BLOCKS[i];
        pos = this.getGridPosition(block.x, block.y);
        flag = block.flag;
        step = block.step;
        feature = block.feature;
        if (feature) {
          this.updateComposite([block, BLOCKS[i + 1], BLOCKS[i + 2], BLOCKS[i + 3]], feature);
          _results.push(i += 4);
        } else {
          if (flag) {
            continue;
          }
          if (step) {
            BLOCKS[i].y += step * HEIGHT;
            delete BLOCKS[i].step;
          }
          _results.push(block.draw(CONTEXT));
        }
      }
      return _results;
    };

    Stage.prototype.requestFrame = function(callback) {
      var enterFrame;
      enterFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
        return setTimeout(callback, 1000 / 60);
      };
      return enterFrame(callback);
    };

    Stage.prototype.render = function() {
      var self;
      self = this;
      return this.requestFrame(function() {
        var delta, now;
        now = +new Date();
        delta = now - START;
        if (delta >= INTERVAL) {
          self.update();
          START = +new Date();
        }
        return self.render();
      });
    };

    Stage.prototype.handleEvent = function(type, code) {
      var is_key_down;
      is_key_down = type === 'keydown';
      if (__indexOf.call(KEY_LEFT, code) >= 0) {
        return VELOCITY_X = is_key_down ? -WIDTH : 0;
      } else if (__indexOf.call(KEY_RIGHT, code) >= 0) {
        return VELOCITY_X = is_key_down ? WIDTH : 0;
      } else if (__indexOf.call(KEY_DOWN, code) >= 0) {
        return VELOCITY_Y = is_key_down ? VELOCITY_Y_RAW + VELOCITY_Y_STEP : VELOCITY_Y_RAW;
      } else if (code === KEY_SPACE) {
        if (is_key_down) {
          return CURRENT_BLOCK_HEADER.updateShape();
        }
      }
    };

    Stage.prototype.bindEvent = function() {
      var evt, self, _i, _len, _ref, _results;
      self = this;
      _ref = ['keydown', 'keyup'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        evt = _ref[_i];
        _results.push(document.addEventListener(evt, function(e) {
          var code, type;
          code = e.keyCode || e.which;
          type = e.type;
          return self.handleEvent(type, code);
        }));
      }
      return _results;
    };

    return Stage;

  })();

  (function() {
    return new Stage;
  })();

}).call(this);
